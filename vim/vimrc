vim9script

# set verbosefile=vimlog.txt
# set verbose=7
set nocompatible

set undodir=/home/lucas/.local/share/vim/undo
set directory=/home/lucas/.local/share/vim/swap
set backupdir=/home/lucas/.local/share/vim/backup
set viewdir=/home/lucas/.local/share/vim/view
set runtimepath=/home/lucas/.config/vim,$VIMRUNTIME,
set runtimepath+=/home/lucas/.config/vim/after
filetype off
set runtimepath+=/usr/share/vim/vimfiles/
filetype on
syntax on
set viminfo+=n/home/lucas/.local/share/vim/viminfo

source /home/lucas/.config/vim/quit.vim

call plug#begin('~/.config/vim/plugged')

Plug 'vim-airline/vim-airline'
Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-fugitive'
Plug 'yegappan/lsp'
Plug 'ap/vim-css-color'
Plug 'romainl/vim-cool'
Plug 'dahu/vim-fanfingtastic'
Plug 'vim-python/python-syntax'
Plug 'lervag/vimtex'

call plug#end()

command! Picon exe 'normal m`'
               \ | silent! undojoin | exe '%!picon -a' | exe 'normal ``'

packadd termdebug
noremap <C-@> :Break<CR>
au CursorHold *.c call EvalSmart()
noremap <leader>c :Continue<CR>
noremap <space>   :Step<CR>
noremap <enter>   :Step<CR>

g:term_debug_on = v:false

au User TermdebugStartPost g:term_debug_on = v:true
au User TermdebugStopPre   g:term_debug_on = v:false

def EvalSmart()
    if !g:term_debug_on
        return
    endif
    var save_pos = getcurpos()
  
    var lnum = line('.')
    var text = getline(lnum)
  
    if text =~ '^#'
        setpos('.', save_pos)
        return
    endif
  
    var c_keywords = [
        'if', 'else', 'while', 'for', 'do', 'switch', 'case', 'default',
        'break', 'continue', 'return', 'goto',
        'sizeof', 'typedef', 'struct', 'union', 'enum',
        'static', 'extern', 'auto', 'register',
        'const', 'volatile', 'restrict',
        'void', 'bool', 'char', 'short', 'int', 'long',
        'float', 'double', 'signed', 'unsigned',
    ]
  
    var colnum = col('.')
    var lastcol = len(text)
  
    while colnum <= lastcol
        if text[colnum - 1] =~ '[_0-9A-Za-z]'
            var start = colnum
            var end = colnum
  
            while end <= lastcol && text[end - 1] =~ '[_0-9A-Za-z]'
                end += 1
            endwhile
  
            var ident = text[start - 1 : end - 2]
  
            if index(c_keywords, ident) >= 0
                colnum = end
                continue
            endif
  
            var tags = taglist('^' .. ident .. '$')
            var is_typedef = v:false
  
            for tag in tags
                if get(tag, 'kind', '') ==# 't'
                    is_typedef = v:true
                    break
                endif
            endfor
  
            if !is_typedef
                cursor(lnum, start)
                execute 'Eval'
                break
            endif
  
            colnum = end
            continue
        endif
  
        colnum += 1
    endwhile
  
    setpos('.', save_pos)
enddef

g:vimtex_view_enabled = 0
g:vimtex_view_Auto = 0

g:vim_markdown_strikethrough = 1
g:netrw_banner = 0
g:airline#extensions#tabline#enabled = 0
g:airline#extensions#tagbar#enabled = 0
g:airline#parts#ffenc#skip_expected_string = 'utf-8[unix]'
g:airline#extensions#tagbar#flags = ''
g:DiffColors = 1

g:gitgutter_signs = 1
g:gitgutter_highlight_lines = 1
g:gitgutter_highlight_linenrs = 0
g:gitgutter_sign_added = '+'
g:gitgutter_sign_modified = '~'
g:gitgutter_sign_removed = '-'
g:gitgutter_sign_removed_first_line = '^'
g:gitgutter_sign_removed_above_and_below = '{'
g:gitgutter_sign_modified_removed = 'w'
g:gitgutter_set_sign_backgrounds = 1
g:gitgutter_map_keys = 0
g:gitgutter_terminal_reports_focus = 0

# fugitive
nnoremap <leader>g :tab Git<CR>
nnoremap <C-g>     :!gitwip.sh % <CR>

g:python_highlight_all = 1

set tags=tags

def g:Gototo()
    var cur_win = win_getid()
    var pos = getcurpos()

    silent! LspGotoDefinition

    if getcurpos() ==# pos
        var word = expand('<cword>')
        var word_escaped = escape(word, '\')
        execute 'tag ' .. word_escaped
        return
    endif

    var new_win = win_getid()

    if new_win != cur_win
        var buf = expand('%:p')
        var saved_pos = getcurpos()
        close
        execute 'edit ' .. fnameescape(buf)
        setpos('.', saved_pos)
    endif
    return
enddef
nnoremap <C-]> :call g:Gototo()<CR>

nnoremap <leader>l :LspDiagNextWrap<CR>
nnoremap <leader>L :LspDiagPrev<CR>
nnoremap <leader>o :LspHover<CR>

def GitGutterNextHunkCycle()
    var line_num = line('.')
    execute 'GitGutterNextHunk'
    if line('.') ==# line_num
        cursor(1, 1)
        execute 'GitGutterNextHunk'
    endif
    return
enddef

nnoremap <leader>p :call GitGutterNextHunkCycle()<CR>
nnoremap <leader>u :GitGutterUndoHunk<CR><CR>

def g:ToggleMarkdownListItem()
    var cursor_line = line('.')
    var line_text = getline(cursor_line)

    if line_text =~ '^\s*\([-*]\|[0-9]\+\.\)\s\+'
        var new_line: string

        if line_text =~ '^\s*\([-*]\|[0-9]\+\.\)\s\+\~\~.*\~\~$'
            new_line = substitute(
                           line_text,
                           '^\(\s*\([-*]\|[0-9]\+\.\)\)\s\+\~\~\(.*\)\~\~$',
                           '\1 \3',
                           ''
                       )
        else
            new_line = substitute(
                           line_text,
                           '^\(\s*\([-*]\|[0-9]\+\.\)\)\s\+\(.*\)$',
                           '\1 ~~\3~~',
                           ''
                       )
        endif

        setline(cursor_line, new_line)
    endif
    return
enddef
# <C-@> is <C-Space> (for what I am sure is a very good reason)
augroup MarkdownListToggle
    autocmd!
    autocmd FileType markdown
        \ nnoremap <buffer> <C-@> :call g:ToggleMarkdownListItem()<CR>
augroup END

augroup SyncTexGroup
    autocmd!
    autocmd FileType tex call SyncTexSetupAuto()
augroup END

def SyncTexSetupAuto()
    autocmd CursorHold <buffer> silent! call SyncTexAutoForward()

    nnoremap <buffer> <Space> :call <SID>SyncTexForward()<CR>
    nnoremap <buffer> <leader>s :call <SID>SyncTexToggleAutoForward()<CR>
    return
enddef

def g:SyncTexBackward(line: string, afile: string)
    synctex_auto_forward_disable = v:true
    silent! execute 'edit +' .. line .. ' ' .. afile
    # redraw!
    return
enddef

def SyncTexForward()
    var cmd = ['zf', string(line('.')), string(col('.')), bufname('%')]
    job_start(cmd)
    return
enddef

def SyncTexAutoForward()
    if synctex_auto_forward_enable && !synctex_auto_forward_disable
        SyncTexForward()
    endif
    return
enddef

def SyncTexToggleAutoForward()
    synctex_auto_forward_enable = !synctex_auto_forward_enable
    if synctex_auto_forward_enable && !synctex_auto_forward_disable
        echo 'SyncTex mode: ON'
    else
        echo 'SyncTex mode: OFF'
    endif
    return
enddef

var synctex_auto_forward_enable = v:false
var synctex_auto_forward_disable = v:false
var synctex_focus_timer = -1

def SyncTexOnFocusTimer(timer_id: number)
    synctex_focus_timer = -1
    synctex_auto_forward_disable = v:false
    return
enddef

def g:SyncTexOnFocusGain()
    if synctex_focus_timer != -1
        timer_stop(synctex_focus_timer)
    endif
    synctex_focus_timer = timer_start(1000, 'SyncTexOnFocusTimer')
    return
enddef

def g:SyncTexOnFocusLost()
    if synctex_focus_timer != -1
        timer_stop(synctex_focus_timer)
        synctex_focus_timer = -1
    endif
    return
enddef

&t_fe = "\<Esc>[?1004h"
&t_fd = "\<Esc>[?1004l"
execute "set <FocusGained>=\<Esc>[I"
execute "set <FocusLost>=\<Esc>[O"

autocmd FocusGained *.tex call SyncTexOnFocusGain()
autocmd FocusLost   *.tex call SyncTexOnFocusLost()

# cursor: format and color (terminal has to support these escape sequences)
&t_SI = &t_SI .. "\<Esc>[5 q\<Esc>]12;blue\x7"
&t_EI = &t_EI .. "\<Esc>[2 q\<Esc>]12;yellow\x7"

set history=1000
set titlelen=0  # don't limit title length
set autowrite
set breakindent autoindent smartindent
set breakindentopt=sbr showbreak=>
set cpoptions+=n
set commentstring=#%s
set shell=/usr/bin/zsh
# set hidden
set noswapfile
set timeoutlen=10000 ttimeoutlen=5
set updatetime=100
set history=10000
set clipboard^=unnamedplus,unnamed
set mouse=a
set mousemodel=popup
set dictionary="/usr/share/dict/words"
set foldmethod=marker foldmarker={,} foldminlines=1 foldlevelstart=100

# Interface
if exists('+termguicolors')
    &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    set termguicolors
    set background=dark
endif
set laststatus=1 showtabline=1 noshowmode showcmd
set number relativenumber
set cursorline cursorcolumn #deixa o VIM lento
set scrolloff=5
set visualbell t_vb=
set splitbelow
set splitright
set wrap

# Find
set path+=**
set pumheight=12
set wildmenu
set wildmode=longest,full
set wildoptions=pum
set wildignore+=*.o
set completeopt=menu

set infercase
set hlsearch incsearch ignorecase smartcase
# Make n always search forward, even when started with ?
nnoremap <expr> n 'Nn'[v:searchforward]
nnoremap <expr> N 'nN'[v:searchforward]
# Formatar
set backspace=indent,eol,start
set tabstop=4 shiftwidth=4 expandtab
set textwidth=80
&colorcolumn = join(range(81, 999), ",")
set autoindent
set autoread
# set formatoptions-=c,r,o,/,b,n,i,j
set conceallevel=2
set termwinsize=10x0
set noautochdir
au CursorHold * checktime
filetype plugin on

colorscheme default
if &term =~ 'st\|xterm\|kitty\|alacritty\|tmux'
    &t_Ts = "\e[9m"   # Strikethrough
    &t_Te = "\e[29m"
    &t_Cs = "\e[4:3m" # Undercurl
    &t_Ce = "\e[4:0m"
endif

source /home/lucas/.config/vim/lspconfig.vim

g:mapleader = '\'
# set shortmess=at

command! Vmake w | silent make -j1 clang | unsilent redraw!
set makeprg=./build.sh
nnoremap <leader>m :Vmake<CR>:LspDiag current<CR>
nnoremap <leader>m :make<CR>

# disable ex mode (what the hell is that shit?)
map Q <Nop>
# :help map-modes
nnoremap U u
nnoremap <C-z> u
inoremap <C-z> <esc>ui
vnoremap <C-c> y
vnoremap <C-x> d
vnoremap S :s/
nnoremap S :%s/

# hjkl;
# h é mapeado para f next (ver plugins)
noremap j h
noremap ; l
noremap k gj
noremap l gk

# some defaults dont make sense
nnoremap Y y$
nnoremap e ea
nnoremap cd 0D
nnoremap ' `
nnoremap ` '
inoremap <C-h> <esc>dbxi

# janela
nnoremap <C-k>  <C-w>w
nnoremap <C-l>  <C-l><C-w>w
tnoremap <C-k>  <C-w>w
tnoremap <C-l>  <C-l><C-w>w
nnoremap <C-w>j <C-w>h
nnoremap <C-w>k <C-w>j
nnoremap <C-w>l <C-w>k
nnoremap <C-w>; <C-w>l
nnoremap <C-w>J <C-w>H
nnoremap <C-w>K <C-w>J
nnoremap <C-w>L <C-w>K
nnoremap <C-w>: <C-w>L
inoremap <C-w>j <esc><C-w>h
inoremap <C-w>k <esc><C-w>j
inoremap <C-w>l <esc><C-w>k
inoremap <C-w>; <esc><C-w>l
inoremap <C-w>J <esc><C-w>H
inoremap <C-w>K <esc><C-w>J
inoremap <C-w>L <esc><C-w>K
inoremap <C-w>: <esc><C-w>L
vnoremap <C-w>j <esc><C-w>h
vnoremap <C-w>k <esc><C-w>j
vnoremap <C-w>l <esc><C-w>k
vnoremap <C-w>; <esc><C-w>l
vnoremap <C-w>J <esc><C-w>H
vnoremap <C-w>K <esc><C-w>J
vnoremap <C-w>L <esc><C-w>K
vnoremap <C-w>: <esc><C-w>L
tnoremap <C-w>j <esc><C-w>h
tnoremap <C-w>k <esc><C-w>j
tnoremap <C-w>l <esc><C-w>k
tnoremap <C-w>; <esc><C-w>l
tnoremap <C-w>J <esc><C-w>H
tnoremap <C-w>K <esc><C-w>J
tnoremap <C-w>L <esc><C-w>K
tnoremap <C-w>: <esc><C-w>L

# completions
inoremap <tab> <c-n>
inoremap <expr> <C-k> pumvisible() ? '<C-n>' : '<C-k>'
inoremap <expr> <C-l> pumvisible() ? '<C-p>' : '<C-l>'
cnoremap <expr> <C-k> pumvisible() ? '<C-n>' : '<C-k>'
cnoremap <expr> <C-l> pumvisible() ? '<C-p>' : '<C-l>'

au BufWritePost ~/.config/X11/*                 !xrdb ~/.config/X11/Xresources
au BufWritePost */nsxiv/key-handler             !nsxiv_keyhandler_update_lf.sed % > ~/.config/lf/nsxiv
au BufWritePost */tmux/tmux.conf                !tmux source-file %
au BufWritePost */sxhkdrc                       !pkill -SIGUSR1 sxhkd
au BufWritePost */dunst/dunstrc                 !killall dunst; setsid -f dunst 2>&1 > /dev/null
au BufWritePost ~/.config/atalhos,*/atalhos.awk !atalhos.awk   ~/.config/atalhos
au BufWritePost */ls_colors.css,*/ls_colors.awk !ls_colors.awk ~/.config/ls_colors.css
au BufWritePost */lf_icons.conf,*/lf_icons.awk  !lf_icons.awk  ~/.config/lf_icons.conf
au BufWritePost */src/dwmblocks2/*              !sudo ./build.sh install; restart.sh dwmblocks2

au BufRead */Makefile,*.mk,
           \*/src/dmenu/*,*/src/sent/*,*/src/st/*,*/src/swarp/*,
           \*/src/lf/*,*/src/nsxiv/*,*/src/nsxiv-extra/* setlocal noexpandtab
au BufRead */Makefile setlocal textwidth=80

au BufWritePost */src/a_c/*.c       !test_c_program.sh % execute
au BufWritePost */src/0wayland/*.c  !test_c_program.sh %
au BufWritePost */src/a_c++/*.cpp   !g++ -Wall -Wextra -Wpedantic % -o /tmp/%.out && /tmp/%.out
au BufWritePost */src/a_python/*.py !python %
au BufWritePost */src/a_rust/*.rs   !rustc % -o /tmp/%.out && /tmp/%.out
# au BufWritePost *.kt !android_studio_shiftf9.sh

# au BufWritePost *.sh,*.bash,*.zsh,PKGBUILD,PKGBUILD.install   !shellcheck -e SC2059 -x %
def RunShellcheck()
    if &filetype ==# 'sh'
      execute '!shellcheck -e SC2059 -x ' .. fnameescape(expand('%:p'))
    endif
    return
enddef

autocmd BufWritePost * call RunShellcheck()

au BufRead,BufNewFile *.mo,*.mod          setlocal filetype=modelica
au BufRead,BufNewFile *.sage              setlocal filetype=python
au BufRead,BufNewFile /var/tmp/fstab*     setlocal filetype=fstab
au BufRead,BufNewFile *.sp,*.MOD          setlocal filetype=spice
au BufRead,BufNewFile *.plt               setlocal filetype=gnuplot
au BufRead,BufNewFile */X11/urxvt         setlocal filetype=xdefaults
au BufRead,BufNewFile */.config/zathura/* setlocal filetype=zathurarc
au BufRead,BufNewFile *.sent              setlocal filetype=sent
au BufRead,BufNewFile *.sed               setlocal filetype=sed
au BufRead,BufNewFile *.pgn               setlocal filetype=pgn
au BufRead,BufNewFile */COMMIT_EDITMSG    setlocal filetype=gitcommit
au BufRead,BufNewFile *.tab               setlocal filetype=tab
au BufRead,BufNewFile */.config/lf/*      setlocal filetype=lf
au BufRead,BufNewFile ~/.config/*         setlocal autochdir
au BufRead,BufNewFile *.bib               setlocal autochdir

# cd to file dir on startup
# au VimEnter * lcd %:p:h

au WinResized * wincmd =
# augroup Mkdir
#   autocmd!
#   autocmd BufWritePre * call mkdir(expand("<afile>:p:h"), "p")
# augroup END

def FzfFindFile()
    var buflist = []
    for buf in range(1, bufnr('$'))
        add(buflist, bufname(buf))
    endfor
    writefile(buflist, '/tmp/vimbuflist')

    var cmd =
        '{/usr/bin/cat /tmp/vimbuflist; find . -type f}'
        .. ' | grep -Ev "\.git/(objects|refs|HEAD|index)"'
        .. ' | grep -Ev "(\.cache|bin)/"'
        .. ' | grep -Ev "\.(aux|run.xml|bbl|blg|toc|tol|lot|loq|lof|lol|log)$"'
        .. ' | grep -Ev "\.(bcf|pdf|idx|mw)$"'
        .. ' | grep -Ev "^\./?$"'
        .. ' | fzf --bind one:accept'

    var file = trim(system(cmd))

    delete('/tmp/vimbuflist')

    if file ==# ''
        redraw!
        return
    endif

    sleep 100m
    while getchar(0) != 0
        # wait until there are no chars to read
    endwhile

    execute 'edit ' .. fnameescape(file)
    redraw!
    return
enddef

command! FzfFindFile call FzfFindFile()
nnoremap <C-f> :FzfFindFile<CR>

def FzfFindRegex()
    var preview_script = 'fzf_bat_preview.bash'

    var cmd =
        'rg --line-number --no-heading .'
        .. ' | fzf --delimiter ":"'
        .. '       --bind one:accept'
        .. '       --preview-window=up,80%,border-rounded'
        .. '       --preview "' .. preview_script .. ' {1} {2}"'

    var out = systemlist(cmd)
    if empty(out)
        redraw!
        return
    endif

    var parts = split(out[0], ':', v:true)
    if len(parts) < 2
        return
    endif

    var file = parts[0]
    var line = str2nr(parts[1])

    execute 'edit ' .. fnameescape(file)
    execute printf(':%d', line)
    normal! zz
    redraw!
    return
enddef

command! FzfFindRegex call FzfFindRegex()
nnoremap <C-h> :FzfFindRegex<CR>

# ignore diacritics on search a à á ã â ä A À Á Ã Â Ä \a
cnoremap <CR>
    \ <C-\>e getcmdtype() =~ '[?/]' ?
        \ substitute(getcmdline(), '\%(\\\)\@<!\a', '[[=\0=]]', 'g') :
        \ getcmdline()<CR><CR>

source /home/lucas/.config/vim/.arquivos.vim
source /home/lucas/.config/vim/cores.vim
